(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define('bulmaCalendar', factory) :
	(global.bulmaCalendar = factory());
}(this, (function () { 'use strict';

class EventEmitter {
  constructor(listeners = []) {
    this._listeners = new Map(listeners);
    this._middlewares = new Map();
  }

  listenerCount(eventName) {
    if (!this._listeners.has(eventName)) {
      return 0;
    }

    const eventListeners = this._listeners.get(eventName);
    return eventListeners.length;
  }

  removeListeners(eventName = null, middleware = false) {
    if (eventName !== null) {
      if (Array.isArray(eventName)) {
        name.forEach(e => this.removeListeners(e, middleware));
      } else {
        this._listeners.delete(eventName);

        if (middleware) {
          this.removeMiddleware(eventName);
        }
      }
    } else {
      this._listeners = new Map();
    }
  }

  middleware(eventName, fn) {
    if (Array.isArray(eventName)) {
      name.forEach(e => this.middleware(e, fn));
    } else {
      if (!Array.isArray(this._middlewares.get(eventName))) {
        this._middlewares.set(eventName, []);
      }

      (this._middlewares.get(eventName)).push(fn);
    }
  }

  removeMiddleware(eventName = null) {
    if (eventName !== null) {
      if (Array.isArray(eventName)) {
        name.forEach(e => this.removeMiddleware(e));
      } else {
        this._middlewares.delete(eventName);
      }
    } else {
      this._middlewares = new Map();
    }
  }

  on(name, callback, once = false) {
    if (Array.isArray(name)) {
      name.forEach(e => this.on(e, callback));
    } else {
      name = name.toString();
      const split = name.split(/,|, | /);

      if (split.length > 1) {
        split.forEach(e => this.on(e, callback));
      } else {
        if (!Array.isArray(this._listeners.get(name))) {
          this._listeners.set(name, []);
        }

        (this._listeners.get(name)).push({once: once, callback: callback});
      }
    }
  }

  once(name, callback) {
    this.on(name, callback, true);
  }

  emit(name, data, silent = false) {
    name = name.toString();
    let listeners = this._listeners.get(name);
    let middlewares = null;
    let doneCount = 0;
    let execute = silent;

    if (Array.isArray(listeners)) {
      listeners.forEach((listener, index) => {
        // Start Middleware checks unless we're doing a silent emit
        if (!silent) {
          middlewares = this._middlewares.get(name);
          // Check and execute Middleware
          if (Array.isArray(middlewares)) {
            middlewares.forEach(middleware => {
              middleware(data, (newData = null) => {
                if (newData !== null) {
                  data = newData;
                }
                doneCount++;
              }, name);
            });

            if (doneCount >= middlewares.length) {
              execute = true;
            }
          } else {
            execute = true;
          }
        }

        // If Middleware checks have been passed, execute
        if (execute) {
          if (listener.once) {
            listeners[index] = null;
          }
          listener.callback(data);
        }
      });

      // Dirty way of removing used Events
      while (listeners.indexOf(null) !== -1) {
        listeners.splice(listeners.indexOf(null), 1);
      }
    }
  }
}

/**
 * Get the number of days in month
 * @method getDaysInMonth
 * @param  {Integer}       year  Year to check if we are facing a leapyear or not
 * @param  {Integer}       month Month for which we want to know the amount of days
 * @return {Integer}              Days amount
 */
const getDaysInMonth = (year, month) => {
  return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
};

/**
 * Compare two dates
 * @method compareDates
 * @param  {Date}     a First date to compare
 * @param  {Date}     b Second Date to compare with
 * @return {Boolean}    True if dates are equal then false
 */
const compareDates = (a, b) => {
  // weak date comparison
  a.setHours(0, 0, 0, 0);
  b.setHours(0, 0, 0, 0);
  return a.getTime() === b.getTime();
};

/**
 * Check if given year is LeapYear or not
 * @method isLeapYear
 * @param  {Integer}   year Year to check
 * @return {Boolean}        True if LeapYear then False
 */
const isLeapYear = year => {
  // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};

/**
 * Parse Date string based on the Date Format given
 * @method parseDate
 * @param  {String}   dateString          Date string to parse
 * @param  {[String}   [format=undefined] Date Format
 * @return {Date}                         Date Object initialized with Date String based on the Date Format
 */
const parseDate = (dateString, format = undefined) => {
  const date = new Date();
  date.setHours(0, 0, 0, 0);

  const formatPattern = /((?:mm?)|(?:dd?)|(?:yyy?y?))[^0-9]((?:mm?)|(?:dd?)|(?:yyy?y?))[^0-9]((?:mm?)|(?:dd?)|(?:yyy?y?))/i;
  const datePattern = /(\d+)[^0-9](\d+)[^0-9](\d+)/i;

  let matchFormat = formatPattern.exec(format);
  if (matchFormat) {
    let matchDate = datePattern.exec(dateString);
    if (matchDate) {
      switch(matchFormat[1][0]) {
      case 'd':
        date.setDate(matchDate[1]);
        break;
      case 'm':
        date.setMonth(matchDate[1] - 1);
        break;
      case 'y':
        date.setFullYear(matchDate[1]);
        break;
      }

      switch(matchFormat[2][0]) {
      case 'd':
        date.setDate(matchDate[2]);
        break;
      case 'm':
        date.setMonth(matchDate[2] - 1);
        break;
      case 'y':
        date.setFullYear(matchDate[2]);
        break;
      }

      switch(matchFormat[3][0]) {
      case 'd':
        date.setDate(matchDate[3]);
        break;
      case 'm':
        date.setMonth(matchDate[3] - 1);
        break;
      case 'y':
        date.setFullYear(matchDate[3]);
        break;
      }
    }
  }

  return date;
};

/**
 * Returns date according to passed format
 * @method getFormatedDate
 * @param {Date}   dt     Date object
 * @param {String} format Format string
 *      d    - day of month
 *      dd   - 2-digits day of month
 *      D    - day of week
 *      m    - month number
 *      mm   - 2-digits month number
 *      M    - short month name
 *      MM   - full month name
 *      yy   - 2-digits year number
 *      yyyy - 4-digits year number
 */
const getFormatedDate = (dt, format, lang) => {
  var items = {
    d: dt.getDate(),
    dd: dt.getDate(),
    D: dt.getDay(),
    m: dt.getMonth() + 1,
    mm: dt.getMonth() + 1,
    M: dt.getMonth(),
    MM: dt.getMonth(),
    yy: dt.getFullYear().toString().substr(-2),
    yyyy: dt.getFullYear()
  };

  items.dd < 10 && (items.dd = '0' + items.dd);
  items.mm < 10 && (items.mm = '0' + items.mm);
  items.D = lang.weekdays[items.D ? items.D - 1 : 6];
  items.M = lang.monthsShort[items.M];
  items.MM = lang.months[items.MM];

  return format.replace(/(?:[dmM]{1,2}|D|yyyy|yy)/g, function(m) {
    return typeof items[m] !== 'undefined' ? items[m] : m;
  });
};

const isString = unknown => (typeof unknown === 'string' || ((!!unknown && typeof unknown === 'object') && Object.prototype.toString.call(unknown) === '[object String]'));

const defaultOptions = {
  startDate: new Date(),
  weekStart: null,
  minDate: null,
  maxDate: null,
  disabledDates: null,
  dateFormat: 'yyyy-mm-dd', // the default data format `field` value
  lang: 'en', // internationalization
  overlay: false,
  closeOnOverlayClick: true,
  closeOnSelect: true,
  iconPreviousMonth: `<svg viewBox="0 0 50 80" xml:space="preserve">
    <polyline fill="none" stroke-width=".5em" stroke-linecap="round" stroke-linejoin="round" points="45.63,75.8 0.375,38.087 45.63,0.375 "/>
  </svg>`,
  iconNextMonth: `<svg viewBox="0 0 50 80" xml:space="preserve">
    <polyline fill="none" stroke-width=".5em" stroke-linecap="round" stroke-linejoin="round" points="0.375,0.375 45.63,38.087 0.375,75.8 "/>
  </svg>`,
  iconPreviousYear: `<svg viewBox="0 0 50 80" xml:space="preserve">
    <polyline fill="none" stroke-width=".5em" stroke-linecap="round" stroke-linejoin="round" points="45.63,75.8 0.375,38.087 45.63,0.375 "/>
  </svg>`,
  iconNextYear: `<svg viewBox="0 0 50 80" xml:space="preserve">
    <polyline fill="none" stroke-width=".5em" stroke-linecap="round" stroke-linejoin="round" points="0.375,0.375 45.63,38.087 0.375,75.8 "/>
  </svg>`
};

const datepicker_langs = {
  ar: {
    weekStart: 0,
    previousMonth: 'الشهر الماضي',
    nextMonth: 'الشهر القادم',
    months: ['يناير', 'فبراير', 'مارس', 'أبريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'],
    monthsShort: ['يناير', 'فبراير', 'مارس', 'أبريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'],
    weekdays: ['السبت', 'الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة'],
    weekdaysShort: ['السبت', 'الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة']
  },
  bn: {
    weekStart: 1,
    months: ['জানুয়ারী', 'ফেব্রুয়ারি', 'মার্চ', 'এপ্রিল', 'মে', 'জুন', 'জুলাই', 'অগাস্ট', 'সেপ্টেম্বর', 'অক্টোবর', 'নভেম্বর', 'ডিসেম্বর'],
    monthsShort: ['জানুয়ারী', 'ফেব্রুয়ারি', 'মার্চ', 'এপ্রিল', 'মে', 'জুন', 'জুলাই', 'অগাস্ট', 'সেপ্টেম্বর', 'অক্টোবর', 'নভেম্বর', 'ডিসেম্বর'],
    weekdays: ['রবিবার', 'সোমবার', 'মঙ্গলবার', 'বুধবার', 'বৃহস্পতিবার', 'শুক্রবার', 'শনিবার'],
    weekdaysShort: ['রবিবার', 'সোমবার', 'মঙ্গলবার', 'বুধবার', 'বৃহস্পতিবার', 'শুক্রবার', 'শনিবার']
  },
  de: {
    weekStart: 1,
    previousMonth: 'Vorheriger Monat',
    nextMonth: 'Nächster Monat',
    months: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
    monthsShort: ['Jan', 'Febr', 'März', 'Apr', 'Mai', 'Juni', 'Juli', 'Aug', 'Sept', 'Okt', 'Nov', 'Dez'],
    weekdays: ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
    weekdaysShort: ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa']
  },
  en: {
    weekStart: 1,
    previousMonth: 'Previous Month',
    nextMonth: 'Next Month',
    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
  },
  es: {
    weekStart: 1,
    previousMonth: 'Mes anterior',
    nextMonth: 'Próximo mes',
    months: ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
    monthsShort: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
    weekdays: ['Domingo', 'Lunes', 'Martes', 'Miércoles', 'Jueves', 'Viernes', 'Sábado'],
    weekdaysShort: ['Dom', 'Lun', 'Mar', 'Mie', 'Jue', 'Vie', 'Sab']
  },
  fa: {
    weekStart: 1,
    months: ['ژانویه', 'فوریه', 'مارس', 'آوریل', 'مه', 'ژوئن', 'ژوئیه', 'اوت', 'سپتامبر', 'اکتبر', 'نوامبر', 'دسامبر'],
    monthsShort: ['ژان', 'فور', 'مار', 'آور', 'مه', 'ژون', 'ژوی', 'اوت', 'سپت', 'اکت', 'نوا', 'دسا'],
    weekdays: ['یک‌شنبه', 'دوشنبه', 'سه‌شنبه', 'چهارشنبه', 'پنج‌شنبه', 'جمعه', 'شنبه', 'یک‌شنبه'],
    weekdaysShort: ['یک', 'دو', 'سه', 'چهار', 'پنج', 'جمعه', 'شنبه', 'یک']
  },
  fr: {
    weekStart: 1,
    previousMonth: 'Mois précédent',
    nextMonth: 'Mois suivant',
    months: ['Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'],
    monthsShort: ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Auo', 'Sep', 'Oct', 'Nov', 'Déc'],
    weekdays: ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'],
    weekdaysShort: ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam']
  },
  hi: {
    weekStart: 1,
    months: ['जनवरी', 'फ़रवरी', 'मार्च', 'अप्रैल', 'मई', 'जून', 'जुलाई', 'अगस्त', 'सितम्बर', 'अक्टूबर', 'नवंबर', 'दिसम्बर'],
    monthsShort: ['जन', 'फ़रवरी', 'मार्च', 'अप्रैल', 'मई', 'जून', 'जुलाई', 'अगस्त', 'सितं', 'अक्टूबर', 'नवं', 'दिसम्बर'],
    weekdays: ['रविवार', 'सोमवार', 'मंगलवार', 'बुधवार', 'गुरुवार', 'शुक्रवार', 'शनिवार'],
    weekdaysShort: ['सूर्य', 'सोम', 'मंगल', 'बुध', 'गुरु', 'शुक्र', 'शनि']
  },
  hr: {
    weekStart: 2,
    previousMonth: 'Prošli mjesec',
    nextMonth: 'Slijedeći mjesec',
    months: ['siječanj', 'veljača', 'ožujak', 'travanj', 'svibanj', 'lipanj', 'srpanj', 'kolovoz', 'rujan', 'listopad', 'studeni', 'prosinac'],
    monthsShort: ['sij', 'velj', 'ožu', 'tra', 'svi', 'lip', 'srp', 'kol', 'ruj', 'lis', 'stu', 'pro'],
    weekdays: ['nedjelja', 'ponedjeljak', 'utorak', 'srijeda', 'četvrtak', 'petak', 'subota'],
    weekdaysShort: ['ned', 'pon', 'uto', 'sri', 'čet', 'pet', 'sub']
  },
  hu: {
    weekStart: 1,
    previousMonth: 'Előző hónap',
    nextMonth: 'Következő hónap',
    months: ['Január', 'Február', 'Március', 'Április', 'Május', 'Június', 'Július', 'Augusztus', 'Szeptember', 'Október', 'November', 'December'],
    monthsShort: ['Jan', 'Feb', 'Már', 'Ápr', 'Máj', 'Jún', 'Júl', 'Aug', 'Szept', 'Okt', 'Nov', 'Dec'],
    weekdays: ['Vasárnap', 'Hétfő', 'Kedd', 'Szerda', 'Csütörtök', 'Péntek', 'Szombat'],
    weekdaysShort: ['V', 'H', 'K', 'Sze', 'Cs', 'P', 'Szo'],
  },
  id: {
    weekStart: 1,
    months: ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'],
    monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'Mei', 'Jun', 'Jul', 'Ags', 'Sep', 'Okt', 'Nov', 'Des'],
    weekdays: ['Minggu', 'Senin', 'Selasa', 'Rabu', 'Kamis', 'Jumat', 'Sabtu'],
    weekdaysShort: ['Mgu', 'Sen', 'Sel', 'Rab', 'Kam', 'Jum', 'Sab']
  },
  it: {
    weekStart: 1,
    previousMonth: 'Mese Precedente',
    nextMonth: 'Prossimo Mese',
    months: ['Gennaio', 'Febbraio', 'Marzo', 'Aprile', 'Maggio', 'Giugno', 'Luglio', 'Agosto', 'Settembre', 'Ottobre', 'Novembre', 'Dicembre'],
    monthsShort: ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'],
    weekdays: ['Domenica', 'Lunedì', 'Martedì', 'Mercoledì', 'Giovedì', 'Venerdì', 'Sabato'],
    weekdaysShort: ['Dom', 'Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab']
  },
  ja: {
    weekStart: 1,
    months: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
    monthsShort: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
    weekdays: ['日曜', '月曜', '火曜', '水曜', '木曜', '金曜', '土曜'],
    weekdaysShort: ['日', '月', '火', '水', '木', '金', '土']
  },
  nl: {
    weekStart: 1,
    previousMonth: 'Vorige Maand',
    nextMonth: 'Volgende Maand',
    months: ['januari', 'februari', 'maart', 'april', 'mei', 'juni', 'juli', 'augustus', 'september', 'oktober', 'november', 'december'],
    monthsShort: ['jan', 'feb', 'mrt', 'apr', 'mei', 'jun', 'jul', 'aug', 'sep', 'okt', 'nov', 'dec'],
    weekdays: ['zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag'],
    weekdaysShort: ['zo', 'ma', 'di', 'wo', 'do', 'vr', 'za']
  },
  pt: {
    weekStart: 1,
    months: ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
    monthsShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
    weekdays: ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'],
    weekdaysShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb']
  },
  'pt-BR': {
    weekStart: 1,
    previousMonth: 'Mês anterior',
    nextMonth: 'Próximo mês',
    months: ['Janeiro', 'Fevereiro', 'Março', 'Abril', 'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro', 'Outubro', 'Novembro', 'Dezembro'],
    monthsShort: ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'],
    weekdays: ['Domingo', 'Segunda-feira', 'Terça-feira', 'Quarta-feira', 'Quinta-feira', 'Sexta-feira', 'Sábado'],
    weekdaysShort: ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb']
  },
  ru: {
    weekStart: 1,
    previousMonth: 'Предыдущий месяц',
    nextMonth: 'Следующий месяц',
    months: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
    monthsShort: ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
    weekdays: ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота'],
    weekdaysShort: ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб']
  },
  sr: {
    weekStart: 2,
    previousMonth: 'Prošli mesec',
    nextMonth: 'Sledeći mesec',
    months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
    monthsShort: ['jan', 'feb', 'mar', 'apr', 'maj', 'jun', 'jul', 'avg', 'sep', 'okt', 'nov', 'dec'],
    weekdays: ['nedelja', 'ponedeljak', 'utorak', 'sreda', 'četvrtak', 'petak', 'subota'],
    weekdaysShort: ['ned', 'pon', 'uto', 'sre', 'čet', 'pet', 'sub']
  },
  th: {
    weekStart: 1,
    previousMonth: 'เดือนก่อนหน้า',
    nextMonth: 'เดือนถัดไป',
    months: ['มกราคม', 'กุมภาพันธ์', 'มีนาคม', 'เมษายน', 'พฤษภาคม', 'มิถุนายน', 'กรกฎาคม', 'สิงหาคม', 'กันยายน', 'ตุลาคม', 'พฤศจิกายน', 'ธันวาคม'],
    monthsShort: ['ม.ค.', 'ก.พ.', 'มี.ค.', 'เม.ย.', 'พ.ค.', 'มิ.ย.', 'ก.ค.', 'ส.ค.', 'ก.ย.', 'ต.ค.', 'พ.ย.', 'ธ.ค.'],
    weekdays: ['อาทิตย์', 'จันทร์', 'อังคาร', 'พุธ', 'พฤหัสบดี', 'ศุกร์', 'เสาร์'],
    weekdaysShort: ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.']
  },
  tr: {
    weekStart: 1,
    previousMonth: 'Önceki Ay',
    nextMonth: 'Gelecek Ay',
    months: ['Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran', 'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık'],
    monthsShort: ['Oca', 'Şub', 'Mar', 'Nis', 'May', 'Haz', 'Tem', 'Ağu', 'Eyl', 'Eki', 'Kas', 'Ara'],
    weekdays: ['Pazar', 'Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi'],
    weekdaysShort: ['Paz', 'Pzt', 'Sal', 'Çar', 'Per', 'Cum', 'Cmt']
  },
  'zh-cn': {
    weekStart: 1,
    previousMonth: '上个月',
    nextMonth: '下个月',
    months: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
    monthsShort: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
    weekdays: ['星期天', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],
    weekdaysShort: ['周日', '周一', '周二', '周三', '周四', '周五', '周六']
  }
};

Element.prototype.addEventsListener = function(events, listener = void 0) {
  if (!Array.isArray(events)) {
    events = [events];
  }

  events.forEach(event => {
    this.addEventListener(event, listener);
  });
};

class datePicker extends EventEmitter {
  constructor(selector, options = {}) {
    super();

    // Determine click event depending on if we are on Touch device or not
    this._clickEvent = ['touchstart' , 'click'];

    this.datepicker = typeof selector === 'string' ? document.querySelector(selector) : selector;
    // An invalid selector or non-DOM node has been provided.
    if (!this.datepicker) {
      throw new Error('An invalid selector or non-DOM node has been provided.');
    }

    /// Set default options and merge with instance defined
    this.options = Object.assign({}, defaultOptions, options);

    // Initiate plugin
    this._init();
  }

  /**
   * Initiate all DOM element containing datePicker class
   * @method
   * @return {Array} Array of all datePicker instances
   */
  static attach(selector = 'input[type="date"]', options = {}) {
    let datepickerInstances = new Array();

    const datepickers = isString(selector) ? document.querySelectorAll(selector) : Array.isArray ? selector : [selector];
    [].forEach.call(datepickers, datepicker => {
      setTimeout(() => {
        datepickerInstances.push(new datePicker(datepicker, options));
      }, 100);
    });
    return datepickerInstances;
  }

  get id() {
    return this._id;
  }

  get lang() {
    return this.options.lang;
  }

  set lang(lang = 'en') {
    this._lang = typeof datepicker_langs[lang] !== 'undefined' ? lang : 'en';
  }

  get date() {
    return this._date;
  }

  set date(date = new Date()) {
    if (isString(date)) {
      this.options.startDate = parseDate(date, this.dateFormat);
    } else {
      this.options.startDate = parseDate(getFormatedDate(date, this.dateFormat, datepicker_langs[this.options.lang]));
      this._date = {
        month: this.options.startDate.getMonth(),
        year: this.options.startDate.getFullYear(),
        day: this.options.startDate.getDate()
      };
    }
  }

  get minDate() {
    return this.options.minDate;
  }

  set minDate(minDate = '1970-01-01') {
    if (isString(minDate)) {
      this.options.minDate = parseDate(minDate, this.dateFormat);
    } else {
      this.options.minDate = parseDate(getFormatedDate(minDate, this.dateFormat, datepicker_langs[this.options.lang]));
    }
  }

  get maxDate() {
    return this.options.maxDate;
  }

  set maxDate(maxDate = '9999-12-31') {
    if (isString(maxDate)) {
      this.options.maxDate = parseDate(maxDate, this.dateFormat);
    } else {
      this.options.maxDate = parseDate(getFormatedDate(maxDate, this.dateFormat, datepicker_langs[this.options.lang]));
    }
  }

  get dateFormat() {
    return this.options.dateFormat;
  }

  set dateFormat(dateFormat = 'yyyy-mm-dd') {
    this.options.dateFormat = dateFormat;
    this._initDates();
    return this;
  }

  /**
   * Initiate plugin instance
   * @method _init
   * @return {datePicker} Current plugin instance
   */
  _init() {
    this._id = 'datePicker' + (new Date()).getTime() + Math.floor(Math.random() * Math.floor(9999));
    this.lang = this.options.lang;
    this._open = false;

    this._initDates();
    this._build();
    this._bindEvents();

    this.emit('datepicker:ready', this._date);

    return this;
  }

  _initDates() {
    // Set the startDate to the input value
    if (this.datepicker.value) {
      this.options.startDate = parseDate(this.datepicker.value);
    }
    // Transform start date according to dateFormat option
    this.date = this.options.startDate;
    this.minDate = this.options.minDate ? this.options.minDate : '1970-01-01';
    this.maxDate = this.options.maxDate ? this.options.maxDate : '9999-12-31';

    if (this.options.disabledDates) {
      for (var i=0; i < this.options.disabledDates.length; i++) {
        this.options.disabledDates[i] = parseDate(getFormatedDate(new Date(this.options.disabledDates[i]), this.dateFormat, datepicker_langs[this.options.lang]));
      }
    }
  }

  /**
   * Build datePicker HTML component and append it to the DOM
   * @method _build
   * @return {datePicker} Current plugin instance
   */
  _build() {
    // Define datePicker Template
    const datePickerFragment = document.createRange().createContextualFragment(`
      <div id='${this.id}' class="datepicker ${this.options.overlay ? 'modal' : ''}">
        ${this.options.overlay ? '<div class="modal-background"></div>' : ''}
        <div class="calendar">
          <div class="calendar-nav">
            <div class="calendar-nav-month">
              <button class="calendar-nav-previous-month button is-small is-text">${this.options.iconPreviousMonth}</button>
              <div class="calendar-month">${datepicker_langs[this.lang].months[this.date.month]}</div>
              <button class="calendar-nav-next-month button is-small is-text">${this.options.iconPreviousMonth}</button>
            </div>
            <div class="calendar-nav-day">
              <div class="calendar-day">${this.date.day}</div>
            </div>
            <div class="calendar-nav-year">
              <button class="calendar-nav-previous-year button is-small is-text">${this.options.iconPreviousYear}</button>
              <div class="calendar-year">${this.date.year}</div>
              <button class="calendar-nav-next-year button is-small is-text">${this.options.iconNextYear}</button>
            </div>
          </div>
          <div class="calendar-container">
            <div class="calendar-header">
              <div class="calendar-date">${this._getDayName(0, true)}</div>
              <div class="calendar-date">${this._getDayName(1, true)}</div>
              <div class="calendar-date">${this._getDayName(2, true)}</div>
              <div class="calendar-date">${this._getDayName(3, true)}</div>
              <div class="calendar-date">${this._getDayName(4, true)}</div>
              <div class="calendar-date">${this._getDayName(5, true)}</div>
              <div class="calendar-date">${this._getDayName(6, true)}</div>
            </div>
            <div class="calendar-body"></div>
          </div>
        </div>
      </div>
    `);

    // Save pointer to each datePicker element for later use
    this.datePickerContainer = datePickerFragment.querySelector('#' + this.id);
    this.datePickerCalendar = this.datePickerContainer.querySelector('.calendar');
    if (this.options.overlay) {
      this.datePickerOverlay = this.datePickerContainer.querySelector('.modal-background');
      this.datePickerCloseButton = this.datePickerContainer.querySelector('.modal-close');
    }
    this.datePickerCalendarNav = this.datePickerCalendar.querySelector('.calendar-nav');
    this.datePickerCalendarNavMonth = this.datePickerCalendar.querySelector('.calendar-month');
    this.datePickerCalendarNavYear = this.datePickerCalendar.querySelector('.calendar-year');
    this.datePickerCalendarNavDay = this.datePickerCalendar.querySelector('.calendar-day');
    this.datePickerCalendarNavPreviousMonth = this.datePickerCalendarNav.querySelector('.calendar-nav-previous-month');
    this.datePickerCalendarNavNextMonth = this.datePickerCalendarNav.querySelector('.calendar-nav-next-month');
    this.datePickerCalendarNavPreviousYear = this.datePickerCalendarNav.querySelector('.calendar-nav-previous-year');
    this.datePickerCalendarNavNextYear = this.datePickerCalendarNav.querySelector('.calendar-nav-next-year');
    this.datePickerCalendarHeader = this.datePickerCalendar.querySelector('.calendar-header');
    this.datePickerCalendarBody = this.datePickerCalendar.querySelector('.calendar-body');

    // Add datepicker HTML element to Document Body
    document.body.appendChild(datePickerFragment);
  }

  /**
   * Bind all events
   * @method _bindEvents
   * @return {void}
   */
  _bindEvents() {
    // Bind event to element in order to display/hide datePicker on click
    this.datepicker.addEventsListener(this._clickEvent, e => {
      e.preventDefault();

      this._open ? this.hide() : this.show();
    });

    if (this.options.overlay) {
      // Bind close event on Close button
      if (this.datePickerCloseButton) {
        this.datePickerCloseButton.addEventsListener(this._clickEvent, e => {
          e.preventDefault();
          this.hide();
        });
      }
      // Bind close event on overlay based on options
      if (this.options.closeOnOverlayClick && this.datePickerOverlay) {
        this.datePickerOverlay.addEventsListener(this._clickEvent, e => {
          e.preventDefault();
          this.hide();
        });
      }
    }

    // Bind year navigation events
    if (this.datePickerCalendarNavPreviousYear) {
      this.datePickerCalendarNavPreviousYear.addEventsListener(this._clickEvent, e => {
        e.preventDefault();
        this.prevYear();
      });
    }
    if (this.datePickerCalendarNavNextYear) {
      this.datePickerCalendarNavNextYear.addEventsListener(this._clickEvent, e => {
        e.preventDefault();
        this.nextYear();
      });
    }

    // Bind month navigation events
    if (this.datePickerCalendarNavPreviousMonth) {
      this.datePickerCalendarNavPreviousMonth.addEventsListener(this._clickEvent, e => {
        e.preventDefault();
        this.prevMonth();
      });
    }
    if (this.datePickerCalendarNavNextMonth) {
      this.datePickerCalendarNavNextMonth.addEventsListener(this._clickEvent, e => {
        e.preventDefault();
        this.nextMonth();
      });
    }
  }

  /**
   * Bind events on each Day item
   * @method _bindDaysEvents
   * @return {void}
   */
  _bindDaysEvents() {
    [].forEach.call(this.datePickerCalendarDays, (calendarDay) => {
      calendarDay.addEventsListener(this._clickEvent, e => {
        e.preventDefault();
        if (!e.currentTarget.classList.contains('is-disabled')) {
          let date = e.currentTarget.dataset.date.split('-');
          let [year, month, day] = date;
          this._date = {
            year: year,
            month: month,
            day: day
          };

          this.emit('datepicker:date:selected', this);

          this.datepicker.value = getFormatedDate((new Date(year, month, day)), this.options.dateFormat, datepicker_langs[this.options.lang]);
          if (this.options.closeOnSelect) {
            this.hide();
          }
        }
      });
    });
  }

  /**
   * Get localized day name
   * @method renderDayName
   * @param  {[type]}      day          [description]
   * @param  {Boolean}     [abbr=false] [description]
   * @return {[type]}                   [description]
   */
  _getDayName(day, abbr = false) {
    // will try to use weekStart from options if provided, also verify if it's in the range 0 ~ 6
    day += typeof this.options.weekStart != 'number' && this.options.weekStart >= 0 && this.options.weekStart <= 6 ? this.options.weekStart : datepicker_langs[this.options.lang].weekStart;
    while (day >= 7) {
      day -= 7;
    }

    return abbr ? datepicker_langs[this.options.lang].weekdaysShort[day] : datepicker_langs[this.options.lang].weekdays[day];
  }

  _renderDay(day, month, year, isSelected, isToday, isDisabled, isEmpty, isBetween, isSelectedIn, isSelectedOut) {
    return `
      <div data-date="${`${year}-${month}-${day}`}" class="calendar-date${isDisabled ? ' is-disabled' : ''}${isBetween ? ' calendar-range' : ''}${isSelectedIn ? ' calendar-range-start' : ''}${isSelectedOut ? ' calendar-range-end' : ''}">
        <button class="date-item${isToday ? ' is-today' : ''}${isSelected ? ' is-active' : ''}">${day}</button>
      </div>
    `;
  }

  _renderDays() {
    const now = new Date();
    let days = '';

    let numberOfDays = getDaysInMonth(this.date.year, this.date.month),
      before = new Date(this.date.year, this.date.month, 1).getDay();

    this.emit('datepicker:rendered', this);

    // Get start day from options
    // will try to use weekStart from options if provided, also verify if it's in the range 0 ~ 6
    const startDay = typeof this.options.weekStart != 'number' && this.options.weekStart >= 0 && this.options.weekStart <= 6 ? this.options.weekStart : datepicker_langs[this.options.lang].weekStart;
    if (startDay > 0) {
      before -= startDay;
      if (before < 0) {
        before += 7;
      }
    }

    let cells = numberOfDays + before,
      after = cells;
    while (after > 7) {
      after -= 7;
    }

    cells += 7 - after;
    for (var i = 0; i < cells; i++) {
      var day = new Date(this.date.year, this.date.month, 1 + (i - before)),
        isBetween = false,
        isSelected = compareDates(day, this.options.startDate),
        isSelectedIn = false,
        isSelectedOut = false,
        isToday = compareDates(day, now),
        isEmpty = i < before || i >= (numberOfDays + before),
        isDisabled = false;

      day.setHours(0, 0, 0, 0);

      if (!isSelected) {
        isSelectedIn = false;
        isSelectedOut = false;
      }

      if (day.getMonth() !== this.date.month || (this.minDate && day.getTime() < this.minDate.getTime()) || (this.maxDate && day.getTime() > this.maxDate.getTime())) {
        isDisabled = true;
      }

      if (this.options.disabledDates) {
        for (var j=0; j < this.options.disabledDates.length; j++) {
          if (day.getTime() == this.options.disabledDates[j].getTime()) {
            isDisabled = true;
          }
        }
      }

      days += this._renderDay(day.getDate(), this.date.month, this.date.year, isSelected, isToday, isDisabled, isEmpty, isBetween, isSelectedIn, isSelectedOut);
    }

    this.datePickerCalendarBody.insertAdjacentHTML('beforeend', days);
    this.datePickerCalendarDays = this.datePickerCalendarBody.querySelectorAll('.calendar-date');
    this._bindDaysEvents();
  }

  /**
   * Navigate to the previous month and regenerate calendar
   * @method prevMonth
   * @return {void}
   */
  prevMonth() {
    this.date.month -= 1;
    this._refreshCalendar();
  }

  _disablePrevMonth() {
    this.datePickerCalendarNavPreviousMonth.setAttribute('disabled', 'disabled');
  }

  _enablePrevMonth() {
    this.datePickerCalendarNavPreviousMonth.removeAttribute('disabled');
  }

  /**
   * Navigate to the next month and regenerate calendar
   * @method nextMonth
   * @return {}
   */
  nextMonth() {
    this.date.month += 1;
    this._refreshCalendar();
  }

  _disableNextMonth() {
    this.datePickerCalendarNavNextMonth.setAttribute('disabled', 'disabled');
  }

  _enableNextMonth() {
    this.datePickerCalendarNavNextMonth.removeAttribute('disabled');
  }

  /**
   * Navigate to the previous year and regenerate calendar
   * @method prevYear
   * @return {void}
   */
  prevYear() {
    this.date.year -= 1;
    this._refreshCalendar();
  }

  _disablePrevYear() {
    this.datePickerCalendarNavPreviousYear.setAttribute('disabled', 'disabled');
  }

  _enablePrevYear() {
    this.datePickerCalendarNavPreviousYear.removeAttribute('disabled');
  }

  /**
   * Navigate to the previous year and regenerate calendar
   * @method nextYear
   * @return {}
   */
  nextYear() {
    this.date.year += 1;
    this._refreshCalendar();
  }

  _disableNextYear() {
    this.datePickerCalendarNavNextYear.setAttribute('disabled', 'disabled');
  }

  _enableNextYear() {
    this.datePickerCalendarNavNextYear.removeAttribute('disabled');
  }

  /**
   * Show datePicker HTML Component
   * @method show
   * @return {void}
   */
  show() {
    // Set the startDate to the input value
    if (this.datepicker.value) {
      this.options.startDate = parseDate(this.datepicker.value);
    }
    this.date.month = this.options.startDate.getMonth();
    this.date.year = this.options.startDate.getFullYear();
    this.date.day = this.options.startDate.getDate();
    this._refreshCalendar();

    this.emit('datepicker:show', this);

    this.datePickerContainer.classList.add('is-active');
    if (!this.options.overlay) {
      this._adjustPosition();
    }
    this._open = true;
  }

  /**
   * Hide datePicker HTML Component
   * @method hide
   * @return {void}
   */
  hide() {
    this._open = false;
    this.emit('datepicker:hide', this);
    this.datePickerContainer.classList.remove('is-active');
  }

  /**
   * Refresh calendar with new year/month days
   * @method _refreshCalendar
   * @return {[type]}        [description]
   */
  _refreshCalendar() {
    if (this.date.month < 0) {
      this.date.year -= Math.ceil(Math.abs(this.date.month) / 12);
      this.date.month += 12;
    }
    if (this.date.month > 11) {
      this.date.year += Math.floor(Math.abs(this.date.month) / 12);
      this.date.month -= 12;
    }
    this.datePickerCalendarNavMonth.innerHTML = datepicker_langs[this.options.lang].months[this.date.month];
    this.datePickerCalendarNavYear.innerHTML = this.date.year;
    this.datePickerCalendarNavDay.innerHTML = this.date.day;
    this.datePickerCalendarBody.innerHTML = '';

    let minMonth = 0,
      minYear = 0,
      maxMonth = 12,
      maxYear = 9999;

    if (this.options.minDate) {
      minMonth = this.options.minDate.getMonth();
      minYear = this.options.minDate.getFullYear();
    }
    if (this.options.maxDate) {
      maxMonth = this.options.maxDate.getMonth();
      maxYear = this.options.maxDate.getFullYear();
    }

    if (this.date.year <= minYear) {
      this._disablePrevYear();
    } else {
      this._enablePrevYear();
    }

    if (this.date.year >= maxYear) {
      this._disableNextYear();
    } else {
      this._enableNextYear();
    }

    if (this.date.year <= minYear && this.date.month <= minMonth) {
      this._disablePrevMonth();
    } else {
      this._enablePrevMonth();
    }

    if (this.date.year >= maxYear && this.date.month >= maxMonth) {
      this._disableNextMonth();
    } else {
      this._enableNextMonth();
    }

    this._renderDays();
    return this;
  }

  /**
   * Recalculate calendar position
   * @method _adjustPosition
   * @return {void}
   */
  _adjustPosition() {
    //var width = this.datePickerCalendar.offsetWidth,
    // height = this.datePickerCalendar.offsetHeight,
    // viewportWidth = window.innerWidth || document.documentElement.clientWidth,
    // viewportHeight = window.innerHeight || document.documentElement.clientHeight,
    // scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop,
    let left, top, clientRect;

    if (typeof this.datepicker.getBoundingClientRect === 'function') {
      clientRect = this.datepicker.getBoundingClientRect();
      left = clientRect.left + window.pageXOffset;
      top = clientRect.bottom + window.pageYOffset;
    } else {
      left = this.datepicker.offsetLeft;
      top = this.datepicker.offsetTop + this.datepicker.offsetHeight;
      while ((this.datepicker = this.datepicker.offsetParent)) {
        left += this.datepicker.offsetLeft;
        top += this.datepicker.offsetTop;
      }
    }

    this.datePickerCalendar.style.position = 'absolute';
    this.datePickerCalendar.style.left = left + 'px';
    this.datePickerCalendar.style.top = top + 'px';
  }

  /**
   * Destroy datePicker
   * @method destroy
   * @return {[type]} [description]
   */
  destroy() {
    this.datePickerCalendar.remove();
  }
}

return datePicker;

})));
